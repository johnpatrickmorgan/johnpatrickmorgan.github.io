
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="johnpatrickmorgan">
    <title>URL Pattern Matching - johnpatrickmorgan</title>
    <meta name="author" content="John Patrick Morgan">
    
        <meta name="keywords" content="Swift,SwiftUI,iOS,swift,pattern-matching,URL routing">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"John Patrick Morgan","sameAs":["https://github.com/johnpatrickmorgan","https://twitter.com/jpmmusic"],"image":"MajorMorgan.jpg"},"articleBody":"When implementing deeplinks for an iOS app recently, I wondered if Swift’s pattern matching could make a viable alternative to a URL routing library. This is an account of the different approaches I tried, and the one I finally settled on.\n\n\nThe majority of URL routing libraries use a pattern syntax that can match each element of a URL’s path in one of three ways:&nbsp;\n\nEquality: Path element must match the pattern expression\nValue-binding: Path element can be anything at all, and will be made available in a parameters dictionary\nWildcard: Path element can be anything at all, and will be discarded\n\nFor example, it might look something like this:\n1234Router.register(&quot;user/:userId/*&quot;) &#123; parameters in   let userId = parameters[&quot;userId&quot;]!   // Show user&#x27;s profile...&#125;\n\nThis would match a URL such as scheme://host/user/john_morgan/profilev2, invoking the closure with a userId of ‘john_morgan’. There are a few reasons I don’t much like this approach:&nbsp;\n\nThe pattern matching is abstracted away using special syntax.\nThe parameter name userId is repeated and stringly typed, so it’s susceptible to typos.\nparameters[&quot;userId&quot;] should never be nil, but the compiler doesn’t know that, so we must force unwrap or add a guard statement.\n\nAs it happens Swift’s built-in pattern matching can be used for each of the three pattern types. Here’s an example of all three:\n12345let example = (&quot;expression-pattern&quot;, &quot;value-binding-pattern&quot;, &quot;wildcard-pattern&quot;)if case let (&quot;expression-pattern&quot;, value, _) = example &#123;   // use value&#125;\n\nIn fact, the expression pattern is more powerful than a simple equality test, as we can define our own matching logic using the pattern matching operator (more of which later). The wildcard pattern is really a special case of the value-binding pattern, so I will refer to them collectively as value-binding patterns from here on in.\nSwift’s pattern-matching would seem a natural fit for matching URLs, and Swift’s switch statement would suit the purpose too, so I decided to investigate a URL routing approach based on the two.\nNSURL exposes a pathComponents as an Array&lt;String&gt;, e.g., https://myhost.com/user/14253/profilev2 would give [&quot;/&quot;, &quot;user&quot;, &quot;14253&quot;, &quot;profilev2&quot;]. Let’s assume we remove the initial backslash and call the resulting array pathElements. In pseudo-Swift, I’d like to be able to switch on the array a bit like this:\n123456switch pathElements &#123;case [&quot;user&quot;, let userId, _]:    // Go to profile for userIddefault:    break&#125;\n\nHowever, there is no built-in pattern matching for Arrays and their elements in Swift, so we need to add it somehow…\nApproach 1: Pattern Matching OperatorMy first thought was to use the pattern-matching operator (~=) to match Arrays of equatable elements based on all elements being equal:\n1234func ~=&lt;T: Equatable&gt;(pattern: [T], value: [T]) -&gt; Bool &#123;    return pattern == value&#125;\n\nThis would allow us to match simple patterns in a switch statement:\n123456switch pathElements &#123;case [&quot;lobby&quot;, &quot;main&quot;]:    // Go to lobbydefault:    break&#125;\n\nHowever, the pattern-matching operator can only be used for expression patterns. It cannot be used for adding custom value-binding patterns, so this is a dead end. We need to convert the array into another type that already supports value-binding patterns for its elements.\nApproach 2: TuplesThis led me to think about tuples, as tuples support value-binding patterns for their elements. To convert the pathElements array into a tuple with the same number of elements, perhaps a decompose() method could be overloaded for element counts up to some sensible limit:\n1234567891011121314151617181920extension Array &#123;    func decompose() -&gt; Element? &#123;        guard count == 1 else &#123; return nil &#125;        return self[0]    &#125;    func decompose() -&gt; (Element, Element)? &#123;        guard count == 2 else &#123; return nil &#125;        return (self[0], self[1])    &#125;    func decompose() -&gt; (Element, Element, Element)? &#123;        guard count == 3 else &#123; return nil &#125;        return (self[0], self[1], self[2])    &#125;&#125;\n\nThis would enable pattern-matching like so:\n123if case (&quot;user&quot;, let userId, _)?: (String, String, String)? = pathElements.decompose() &#123;    // Open profile for userId&#125;\n\nUnfortunately the compiler can’t infer which decompose() method to invoke, which necessitates the explicit typing after the colon above. Abandoning the overloaded decompose() in favour of unique method names decompose1(), decompose2(), decompose3() etc. helps to clean things up:\n12345if case (&quot;user&quot;, let userId, _)? = pathElements.decompose3() &#123;    // Open profile for userId&#125; else if case (&quot;lobby&quot;, &quot;home&quot;)? = pathElements.decompose2() &#123;    // Open lobby&#125;\n\nHowever, this serves to highlight a limitation: we can’t use this approach to match multiple patterns within a single switch statement, unless those patterns happen to have the same element count. In the example above, what would we switch on - decompose2() or decompose3()? Instead, we need a structure that can represent different element counts within the same type…\nApproach 3: Linked ListThis led me to try using an enum type, as enums also support value-binding patterns for their associated values. A linked list (here’s a nice implementation by Airspeed Velocity) seemed promising because it’s built out of enums and can represent an arbitrary number of elements. Here’s what it would look like:\n123if case .Node(&quot;user&quot;, .Node(let userId, .Node(_, .End))) = List(pathElements) &#123;    // Open profile for userId&#125;\n\nUnlike the previous approach, it can also be used to pattern-match lists of any size within a single switch statement:\n12345678910111213switch List(pathElements) &#123;case .End, .Node(&quot;&quot;, .End):    // Open homecase .Node(&quot;lobby&quot;, .Node(&quot;main&quot;, .End)):    // Open lobbycase .Node(&quot;user&quot;, .Node(let userId, .Node(_, .End))):    // Open profile for userIdcase .Node(&quot;user&quot;, .Node(_, .Node(&quot;login&quot;, .End))):    // Open logindefault:    break&#125;\n\nThe trouble is, well, it’s ugly. All those parentheses and repeated .Nodes make it very difficult to read. .Node could be shortened to a single character but nesting multiple enums still generates a confusing amount of parentheses.\nApproach 4: CountedMy final approach was a compromise between approaches 2 and 3. What was needed was an enum that could represent arbitrary numbers of elements without needing too many layers of nesting. Enter Counted:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445enum Counted&lt;E&gt; &#123;    case N0    case N1(E)    case N2(E, E)    case N3(E, E, E)    case N4(E, E, E, E)    case N5(E, E, E, E, E)    case N6(E, E, E, E, E, E)    case N7(E, E, E, E, E, E, E)    case N8(E, E, E, E, E, E, E, E)    case N9(E, E, E, E, E, E, E, E, E)    indirect case N10(E, E, E, E, E, E, E, E, E, E, plus: Counted&lt;E&gt;)    init(_ elements: [E]) &#123;        let e = elements        switch e.count &#123;        case 0:            self = .N0        case 1:            self = .N1(e[0])        case 2:            self = .N2(e[0], e[1])        case 3:            self = .N3(e[0], e[1], e[2])        case 4:            self = .N4(e[0], e[1], e[2], e[3])        case 5:            self = .N5(e[0], e[1], e[2], e[3], e[4])        case 6:            self = .N6(e[0], e[1], e[2], e[3], e[4], e[5])        case 7:            self = .N7(e[0], e[1], e[2], e[3], e[4], e[5], e[6])        case 8:            self = .N8(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7])        case 9:            self = .N9(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8])        default:            self = .N10(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], plus: Counted(Array(e[10..&lt;elements.endIndex])))        &#125;    &#125;&#125;\n\nCounted is an enum where each case has a different number of elements as associated values. It can be initialized with an Array, and just like List, there’s an indirect case that enables arbitrarily large arrays to be represented via nested Counted enums. Unlike List, a layer of nesting is only required for every 10 elements, which makes things easier to read. Counted enables us to pattern-match paths with any number of elements, and supports expression and value-binding patterns for its associated values. It can also be used in switch statements:\n123456789101112switch Counted(pathElements) &#123;case .N0, .N1(&quot;&quot;):    // Open homecase .N2(&quot;lobby&quot;, &quot;main&quot;):    // Open lobbycase .N3(&quot;user&quot;, let userId, &quot;profile&quot;):    // Open profile for userIdcase .N3(&quot;user&quot;, _, &quot;login&quot;):    // Open logindefault:    break&#125;\n\nThis can be extended for even greater flexibility. I mentioned that the expression pattern can be used to match based on more than simple equality. For example, I created a Regex struct that can match Strings based on a regular expression, and implemented the pattern-matching operator like so:\n1234public func ~=(regex: Regex, string: String) -&gt; Bool &#123;    return regex.matches(string)&#125;\n\nAs a result we can use Regex to match individual path elements within Counted. For example, the following case would match both /pages/contact-us_gbr and /pages/contact-us_usa:\n12case .N2(&quot;pages&quot;, Regex(&quot;contact_.*&quot;)):    // Open contact page\n\nI added structs Begins(...) and Ends(...), which use the pattern-matching operator to match Counted instances based purely on a slice of the path elements. I also added extensions to NSURL and NSURLComponents to make a Counted list of path elements and a Dictionary of query arguments easily available. The code is available here: URLPatterns.\nDeep-linkingNow that I can do more idiomatic Swift pattern-matching for URL path elements, here’s how I use it for deep-linking. I define my app’s deep-link destinations as an enum:\n123456enum DeepLink &#123;    case Home, History, Settings, Terms, News, Contact    case Chat(room: String)    case Profile(userId: String)&#125;\n\nI then add a failable initializer to DeepLink, which takes an NSURL. This is where the pattern-matching happens:\n12345678910111213141516171819202122extension DeepLink &#123;    init?(url: NSURL) &#123;        guard url.scheme == &quot;myscheme&quot; else &#123; return nil &#125;        guard url.host == &quot;myhost&quot; else &#123; return nil &#125;        switch url.countedPathComponents() &#123;        case .N0, .N1(&quot;&quot;):                          self = .Home        case .N1(&quot;history&quot;):                        self = .History        case .N2(_, &quot;settings&quot;):                    self = .Settings        case .N2(&quot;chat&quot;, let room):                 self = .Chat(room: room)        case .N3(&quot;users&quot;, let userId, &quot;profile&quot;):   self = .Profile(userId: userId)        case Begins(&quot;news&quot;, &quot;latest&quot;):              self = .News        case Ends(&quot;terms&quot;):                         self = .Terms        case .N2(&quot;pages&quot;, Regex(&quot;contact-us.*&quot;))    self = .Contact        default:                                    return nil        &#125;    &#125;&#125;\n\nOnce the URL has been converted into a DeepLink, it can be passed to a DeepLinker for routing:\n123456struct DeepLinker &#123;    static func open(link: DeepLink, animated: Bool = true) -&gt; Bool &#123;         // switch on link, selecting tabs, pushing and presenting view controllers as appropriate    &#125;&#125;\n\nWith that set up, opening a deeplink looks like this:\n123if let link = DeepLink(url: url) &#123;    DeepLinker.open(link)&#125;\n\nI prefer this approach to the approach taken by most URL routing libraries for a few reasons:\n\nIt’s simple to bypass URLs and open a deeplink directly, e.g. by calling DeepLinker.open(.Home).\n\nThe pattern-matching code is no longer in a third-party library, which makes it easier to debug.\n\nThe pattern-matching code leverages Swift’s built-in pattern-matching, which means it can be customized and extended.\n\nThe pattern-matching and routing processes are separated into two steps. This provides an override point if needed, e.g.:\n\n\n123if let link = DeepLink(url: url) where !link.requiresLogin &#123;    DeepLinker.open(link)&#125;\n\nWhat do you think? Do you like the ‘swiftier’ approach (damn, I nearly managed to avoid that word), or am I misrepresenting URL routing libraries?  \n","dateCreated":"2016-05-11T21:10:39+01:00","dateModified":"2021-07-05T21:48:40+01:00","datePublished":"2016-05-11T21:10:39+01:00","description":"When implementing deeplinks for an iOS app recently, I wondered if Swift’s pattern matching could make a viable alternative to a URL routing library. This is an account of the different approaches I tried, and the one I finally settled on.","headline":"URL Pattern Matching","image":["Abacus.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"},"publisher":{"@type":"Organization","name":"John Patrick Morgan","sameAs":["https://github.com/johnpatrickmorgan","https://twitter.com/jpmmusic"],"image":"MajorMorgan.jpg","logo":{"@type":"ImageObject","url":"MajorMorgan.jpg"}},"url":"https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/","keywords":"Swift, Pattern Matching, URL Routing","thumbnailUrl":"Abacus.jpg"}</script>
    <meta name="description" content="When implementing deeplinks for an iOS app recently, I wondered if Swift’s pattern matching could make a viable alternative to a URL routing library. This is an account of the different approaches I t">
<meta property="og:type" content="blog">
<meta property="og:title" content="URL Pattern Matching">
<meta property="og:url" content="https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/index.html">
<meta property="og:site_name" content="johnpatrickmorgan">
<meta property="og:description" content="When implementing deeplinks for an iOS app recently, I wondered if Swift’s pattern matching could make a viable alternative to a URL routing library. This is an account of the different approaches I t">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-05-11T20:10:39.000Z">
<meta property="article:modified_time" content="2021-07-05T20:48:40.755Z">
<meta property="article:author" content="John Patrick Morgan">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Pattern Matching">
<meta property="article:tag" content="URL Routing">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@jpmmusic">
    
    
        
    
    
        <meta property="og:image" content="https://johnpatrickmorgan.github.io/assets/images/MajorMorgan.jpg"/>
    
    
        <meta property="og:image" content="https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/Abacus.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/Abacus.jpg"/>
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-epcsa1nqmtgul3o7hxuoq5zgbz1flaj2br28cifzmbm0aysxvypib8ntdnps.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78016335-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-78016335-1');
    </script>


    

    
        
            
<link rel="stylesheet" href="/assets/css/gitment.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            johnpatrickmorgan
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="3">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">John Patrick Morgan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Recovering Objective-C developer, one-time <a target="_blank" rel="noopener" href="http://www.johnpatrickmorgan.co.uk/">music composer</a>, now evolving with Swift.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/johnpatrickmorgan"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/jpmmusic"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            URL Pattern Matching
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2016-05-11T21:10:39+01:00">
	
		    May 11, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Swift/">Swift</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p><strong>When implementing deeplinks for an iOS app recently, I wondered if Swift’s pattern matching could make a viable alternative to a URL routing library. This is an account of the different approaches I tried, and the one I finally settled on.</strong></p>
<span id="more"></span>

<p>The majority of URL routing libraries use a pattern syntax that can match each element of a URL’s path in one of three ways:<br>&nbsp;</p>
<ul>
<li><strong>Equality</strong>: Path element must match the pattern expression</li>
<li><strong>Value-binding</strong>: Path element can be anything at all, and will be made available in a parameters dictionary</li>
<li><strong>Wildcard</strong>: Path element can be anything at all, and will be discarded</li>
</ul>
<p>For example, it might look something like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Router</span>.register(<span class="string">&quot;user/:userId/*&quot;</span>) &#123; parameters <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">let</span> userId <span class="operator">=</span> parameters[<span class="string">&quot;userId&quot;</span>]<span class="operator">!</span></span><br><span class="line">   <span class="comment">// Show user&#x27;s profile...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This would match a URL such as <code>scheme://host/user/john_morgan/profilev2</code>, invoking the closure with a <code>userId</code> of ‘john_morgan’. There are a few reasons I don’t much like this approach:<br>&nbsp;</p>
<ul>
<li>The pattern matching is abstracted away using special syntax.</li>
<li>The parameter name <code>userId</code> is repeated and <em>stringly</em> typed, so it’s susceptible to typos.</li>
<li><code>parameters[&quot;userId&quot;]</code> should never be nil, but the compiler doesn’t know that, so we must force unwrap or add a <code>guard</code> statement.</li>
</ul>
<p>As it happens Swift’s built-in pattern matching can be used for each of the three pattern types. Here’s an example of all three:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> example <span class="operator">=</span> (<span class="string">&quot;expression-pattern&quot;</span>, <span class="string">&quot;value-binding-pattern&quot;</span>, <span class="string">&quot;wildcard-pattern&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> (<span class="string">&quot;expression-pattern&quot;</span>, value, <span class="keyword">_</span>) <span class="operator">=</span> example &#123;</span><br><span class="line">   <span class="comment">// use value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In fact, the expression pattern is more powerful than a simple equality test, as we can define our own matching logic using the pattern matching operator (more of which later). The wildcard pattern is really a special case of the value-binding pattern, so I will refer to them collectively as <strong>value-binding</strong> patterns from here on in.</p>
<p>Swift’s pattern-matching would seem a natural fit for matching URLs, and Swift’s switch statement would suit the purpose too, so I decided to investigate a URL routing approach based on the two.</p>
<p>NSURL exposes a <code>pathComponents</code> as an <code>Array&lt;String&gt;</code>, e.g., <code>https://myhost.com/user/14253/profilev2</code> would give <code>[&quot;/&quot;, &quot;user&quot;, &quot;14253&quot;, &quot;profilev2&quot;]</code>. Let’s assume we remove the initial backslash and call the resulting array <code>pathElements</code>. In pseudo-Swift, I’d like to be able to switch on the array a bit like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> pathElements &#123;</span><br><span class="line"><span class="keyword">case</span> [<span class="string">&quot;user&quot;</span>, <span class="keyword">let</span> userId, <span class="keyword">_</span>]:</span><br><span class="line">    <span class="comment">// Go to profile for userId</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, there is no built-in pattern matching for Arrays and their elements in Swift, so we need to add it somehow…</p>
<h2 id="Approach-1-Pattern-Matching-Operator"><a href="#Approach-1-Pattern-Matching-Operator" class="headerlink" title="Approach 1: Pattern Matching Operator"></a>Approach 1: Pattern Matching Operator</h2><p>My first thought was to use the pattern-matching operator (<code>~=</code>) to match Arrays of equatable elements based on all elements being equal:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">~=&lt;</span></span><span class="type">T</span>: <span class="type">Equatable</span><span class="operator">&gt;</span>(pattern: [<span class="type">T</span>], value: [<span class="type">T</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pattern <span class="operator">==</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This would allow us to match simple patterns in a switch statement:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> pathElements &#123;</span><br><span class="line"><span class="keyword">case</span> [<span class="string">&quot;lobby&quot;</span>, <span class="string">&quot;main&quot;</span>]:</span><br><span class="line">    <span class="comment">// Go to lobby</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, the pattern-matching operator can only be used for <strong>expression</strong> patterns. It cannot be used for adding custom <strong>value-binding</strong> patterns, so this is a dead end. We need to convert the array into another type that already supports <strong>value-binding</strong> patterns for its elements.</p>
<h2 id="Approach-2-Tuples"><a href="#Approach-2-Tuples" class="headerlink" title="Approach 2: Tuples"></a>Approach 2: Tuples</h2><p>This led me to think about tuples, as tuples support <strong>value-binding</strong> patterns for their elements. To convert the <code>pathElements</code> array into a tuple with the same number of elements, perhaps a <code>decompose()</code> method could be overloaded for element counts up to some sensible limit:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">decompose</span>()</span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> count <span class="operator">==</span> <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">decompose</span>()</span> -&gt; (<span class="type">Element</span>, <span class="type">Element</span>)<span class="operator">?</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> count <span class="operator">==</span> <span class="number">2</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span>[<span class="number">0</span>], <span class="keyword">self</span>[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">decompose</span>()</span> -&gt; (<span class="type">Element</span>, <span class="type">Element</span>, <span class="type">Element</span>)<span class="operator">?</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> count <span class="operator">==</span> <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span>[<span class="number">0</span>], <span class="keyword">self</span>[<span class="number">1</span>], <span class="keyword">self</span>[<span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This would enable pattern-matching like so:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> (<span class="string">&quot;user&quot;</span>, <span class="keyword">let</span> userId, <span class="keyword">_</span>)<span class="operator">?</span>: (<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>)<span class="operator">?</span> <span class="operator">=</span> pathElements.decompose() &#123;</span><br><span class="line">    <span class="comment">// Open profile for userId</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unfortunately the compiler can’t infer which <code>decompose()</code> method to invoke, which necessitates the explicit typing after the colon above. Abandoning the overloaded <code>decompose()</code> in favour of unique method names <code>decompose1()</code>, <code>decompose2()</code>, <code>decompose3()</code> etc. helps to clean things up:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> (<span class="string">&quot;user&quot;</span>, <span class="keyword">let</span> userId, <span class="keyword">_</span>)<span class="operator">?</span> <span class="operator">=</span> pathElements.decompose3() &#123;</span><br><span class="line">    <span class="comment">// Open profile for userId</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">case</span> (<span class="string">&quot;lobby&quot;</span>, <span class="string">&quot;home&quot;</span>)<span class="operator">?</span> <span class="operator">=</span> pathElements.decompose2() &#123;</span><br><span class="line">    <span class="comment">// Open lobby</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, this serves to highlight a limitation: we can’t use this approach to match multiple patterns within a single switch statement, unless those patterns happen to have the same element count. In the example above, what would we switch on - <code>decompose2()</code> or <code>decompose3()</code>? Instead, we need a structure that can represent different element counts within the same type…</p>
<h2 id="Approach-3-Linked-List"><a href="#Approach-3-Linked-List" class="headerlink" title="Approach 3: Linked List"></a>Approach 3: Linked List</h2><p>This led me to try using an enum type, as enums also support <strong>value-binding</strong> patterns for their associated values. A linked list (here’s a nice <a target="_blank" rel="noopener" href="https://airspeedvelocity.net/2015/07/26/linked-lists-enums-value-types-and-identity/">implementation by Airspeed Velocity</a>) seemed promising because it’s built out of enums and can represent an arbitrary number of elements. Here’s what it would look like:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Node</span>(<span class="string">&quot;user&quot;</span>, .<span class="type">Node</span>(<span class="keyword">let</span> userId, .<span class="type">Node</span>(<span class="keyword">_</span>, .<span class="type">End</span>))) <span class="operator">=</span> <span class="type">List</span>(pathElements) &#123;</span><br><span class="line">    <span class="comment">// Open profile for userId</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unlike the previous approach, it can also be used to pattern-match lists of any size within a single switch statement:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="type">List</span>(pathElements) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> .<span class="type">End</span>, .<span class="type">Node</span>(<span class="string">&quot;&quot;</span>, .<span class="type">End</span>):</span><br><span class="line">    <span class="comment">// Open home</span></span><br><span class="line"><span class="keyword">case</span> .<span class="type">Node</span>(<span class="string">&quot;lobby&quot;</span>, .<span class="type">Node</span>(<span class="string">&quot;main&quot;</span>, .<span class="type">End</span>)):</span><br><span class="line">    <span class="comment">// Open lobby</span></span><br><span class="line"><span class="keyword">case</span> .<span class="type">Node</span>(<span class="string">&quot;user&quot;</span>, .<span class="type">Node</span>(<span class="keyword">let</span> userId, .<span class="type">Node</span>(<span class="keyword">_</span>, .<span class="type">End</span>))):</span><br><span class="line">    <span class="comment">// Open profile for userId</span></span><br><span class="line"><span class="keyword">case</span> .<span class="type">Node</span>(<span class="string">&quot;user&quot;</span>, .<span class="type">Node</span>(<span class="keyword">_</span>, .<span class="type">Node</span>(<span class="string">&quot;login&quot;</span>, .<span class="type">End</span>))):</span><br><span class="line">    <span class="comment">// Open login</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The trouble is, well, it’s ugly. All those parentheses and repeated <code>.Node</code>s make it very difficult to read. <code>.Node</code> could be shortened to a single character but nesting multiple enums still generates a confusing amount of parentheses.</p>
<h2 id="Approach-4-Counted"><a href="#Approach-4-Counted" class="headerlink" title="Approach 4: Counted"></a>Approach 4: Counted</h2><p>My final approach was a compromise between approaches 2 and 3. What was needed was an enum that could represent arbitrary numbers of elements without needing too many layers of nesting. Enter <code>Counted</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Counted</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">N0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">N1</span>(<span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N2</span>(<span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N3</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N4</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N5</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N6</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N7</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N8</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">N9</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">N10</span>(<span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, <span class="type">E</span>, plus: <span class="type">Counted</span>&lt;<span class="type">E</span>&gt;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">elements</span>: [<span class="type">E</span>])</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> e <span class="operator">=</span> elements</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> e.count &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N0</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N1</span>(e[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N2</span>(e[<span class="number">0</span>], e[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N3</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N4</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>], e[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N5</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>], e[<span class="number">3</span>], e[<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N6</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>], e[<span class="number">3</span>], e[<span class="number">4</span>], e[<span class="number">5</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N7</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>], e[<span class="number">3</span>], e[<span class="number">4</span>], e[<span class="number">5</span>], e[<span class="number">6</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N8</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>], e[<span class="number">3</span>], e[<span class="number">4</span>], e[<span class="number">5</span>], e[<span class="number">6</span>], e[<span class="number">7</span>])</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N9</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>], e[<span class="number">3</span>], e[<span class="number">4</span>], e[<span class="number">5</span>], e[<span class="number">6</span>], e[<span class="number">7</span>], e[<span class="number">8</span>])</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">N10</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], e[<span class="number">2</span>], e[<span class="number">3</span>], e[<span class="number">4</span>], e[<span class="number">5</span>], e[<span class="number">6</span>], e[<span class="number">7</span>], e[<span class="number">8</span>], e[<span class="number">9</span>], plus: <span class="type">Counted</span>(<span class="type">Array</span>(e[<span class="number">10</span><span class="operator">..&lt;</span>elements.endIndex])))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Counted is an enum where each case has a different number of elements as associated values. It can be initialized with an Array, and just like <code>List</code>, there’s an indirect case that enables arbitrarily large arrays to be represented via nested <code>Counted</code> enums. Unlike <code>List</code>, a layer of nesting is only required for every 10 elements, which makes things easier to read. <code>Counted</code> enables us to pattern-match paths with any number of elements, and supports <strong>expression</strong> and <strong>value-binding</strong> patterns for its associated values. It can also be used in switch statements:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="type">Counted</span>(pathElements) &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">N0</span>, .<span class="type">N1</span>(<span class="string">&quot;&quot;</span>):</span><br><span class="line">    <span class="comment">// Open home</span></span><br><span class="line"><span class="keyword">case</span> .<span class="type">N2</span>(<span class="string">&quot;lobby&quot;</span>, <span class="string">&quot;main&quot;</span>):</span><br><span class="line">    <span class="comment">// Open lobby</span></span><br><span class="line"><span class="keyword">case</span> .<span class="type">N3</span>(<span class="string">&quot;user&quot;</span>, <span class="keyword">let</span> userId, <span class="string">&quot;profile&quot;</span>):</span><br><span class="line">    <span class="comment">// Open profile for userId</span></span><br><span class="line"><span class="keyword">case</span> .<span class="type">N3</span>(<span class="string">&quot;user&quot;</span>, <span class="keyword">_</span>, <span class="string">&quot;login&quot;</span>):</span><br><span class="line">    <span class="comment">// Open login</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This can be extended for even greater flexibility. I mentioned that the <strong>expression</strong> pattern can be used to match based on more than simple equality. For example, I created a <code>Regex</code> struct that can match Strings based on a regular expression, and implemented the pattern-matching operator like so:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">~=</span>(<span class="params">regex</span>: <span class="type">Regex</span>, <span class="params">string</span>: <span class="type">String</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regex.matches(string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As a result we can use <code>Regex</code> to match individual path elements within <code>Counted</code>. For example, the following case would match both <code>/pages/contact-us_gbr</code> and <code>/pages/contact-us_usa</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> .<span class="type">N2</span>(<span class="string">&quot;pages&quot;</span>, <span class="type">Regex</span>(<span class="string">&quot;contact_.*&quot;</span>)):</span><br><span class="line">    <span class="comment">// Open contact page</span></span><br></pre></td></tr></table></figure>

<p>I added structs <code>Begins(...)</code> and <code>Ends(...)</code>, which use the <a target="_blank" rel="noopener" href="https://github.com/johnpatrickmorgan/URLPatterns/blob/master/URLPatterns/Classes/CountedExpressionMatching.swift">pattern-matching operator</a> to match <code>Counted</code> instances based purely on a slice of the path elements. I also added extensions to <code>NSURL</code> and <code>NSURLComponents</code> to make a <code>Counted</code> list of path elements and a <code>Dictionary</code> of query arguments easily available. The code is available here: <a target="_blank" rel="noopener" href="https://github.com/johnpatrickmorgan/URLPatterns">URLPatterns</a>.</p>
<h2 id="Deep-linking"><a href="#Deep-linking" class="headerlink" title="Deep-linking"></a>Deep-linking</h2><p>Now that I can do more idiomatic Swift pattern-matching for URL path elements, here’s how I use it for deep-linking. I define my app’s deep-link destinations as an enum:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DeepLink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Home</span>, <span class="type">History</span>, <span class="type">Settings</span>, <span class="type">Terms</span>, <span class="type">News</span>, <span class="type">Contact</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Chat</span>(room: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Profile</span>(userId: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I then add a failable initializer to <code>DeepLink</code>, which takes an <code>NSURL</code>. This is where the pattern-matching happens:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DeepLink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">url</span>: <span class="type">NSURL</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> url.scheme <span class="operator">==</span> <span class="string">&quot;myscheme&quot;</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">guard</span> url.host <span class="operator">==</span> <span class="string">&quot;myhost&quot;</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> url.countedPathComponents() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">N0</span>, .<span class="type">N1</span>(<span class="string">&quot;&quot;</span>):                          <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Home</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">N1</span>(<span class="string">&quot;history&quot;</span>):                        <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">History</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">N2</span>(<span class="keyword">_</span>, <span class="string">&quot;settings&quot;</span>):                    <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Settings</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">N2</span>(<span class="string">&quot;chat&quot;</span>, <span class="keyword">let</span> room):                 <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Chat</span>(room: room)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">N3</span>(<span class="string">&quot;users&quot;</span>, <span class="keyword">let</span> userId, <span class="string">&quot;profile&quot;</span>):   <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Profile</span>(userId: userId)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Begins</span>(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;latest&quot;</span>):              <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">News</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Ends</span>(<span class="string">&quot;terms&quot;</span>):                         <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Terms</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">N2</span>(<span class="string">&quot;pages&quot;</span>, <span class="type">Regex</span>(<span class="string">&quot;contact-us.*&quot;</span>))    <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Contact</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:                                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Once the URL has been converted into a <code>DeepLink</code>, it can be passed to a <code>DeepLinker</code> for routing:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeepLinker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">open</span>(<span class="params">link</span>: <span class="type">DeepLink</span>, <span class="params">animated</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">         <span class="comment">// switch on link, selecting tabs, pushing and presenting view controllers as appropriate</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that set up, opening a deeplink looks like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> link <span class="operator">=</span> <span class="type">DeepLink</span>(url: url) &#123;</span><br><span class="line">    <span class="type">DeepLinker</span>.open(link)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I prefer this approach to the approach taken by most URL routing libraries for a few reasons:</p>
<ul>
<li><p>It’s simple to bypass URLs and open a deeplink directly, e.g. by calling <code>DeepLinker.open(.Home)</code>.</p>
</li>
<li><p>The pattern-matching code is no longer in a third-party library, which makes it easier to debug.</p>
</li>
<li><p>The pattern-matching code leverages Swift’s built-in pattern-matching, which means it can be customized and extended.</p>
</li>
<li><p>The pattern-matching and routing processes are separated into two steps. This provides an override point if needed, e.g.:</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> link <span class="operator">=</span> <span class="type">DeepLink</span>(url: url) <span class="keyword">where</span> <span class="operator">!</span>link.requiresLogin &#123;</span><br><span class="line">    <span class="type">DeepLinker</span>.open(link)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What do you think? Do you like the ‘swiftier’ approach (damn, I nearly managed to avoid that word), or am I misrepresenting URL routing libraries?  </p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Pattern-Matching/" rel="tag">Pattern Matching</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Swift/" rel="tag">Swift</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/URL-Routing/" rel="tag">URL Routing</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/07/03/NStack/"
                    data-tooltip="Improving SwiftUI Navigation for the Coordinator Pattern"
                    aria-label="PREVIOUS: Improving SwiftUI Navigation for the Coordinator Pattern"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitment"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitment"></div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyright &copy; 2021 John Patrick Morgan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/07/03/NStack/"
                    data-tooltip="Improving SwiftUI Navigation for the Coordinator Pattern"
                    aria-label="PREVIOUS: Improving SwiftUI Navigation for the Coordinator Pattern"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitment"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="3">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">John Patrick Morgan</h4>
        
            <div id="about-card-bio"><p>Recovering Objective-C developer, one-time <a target="_blank" rel="noopener" href="http://www.johnpatrickmorgan.co.uk/">music composer</a>, now evolving with Swift.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p><a target="_blank" rel="noopener" href="https://joinzoe.com/">ZOE</a></p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                London
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-dli0zl8vd3wl2erskfanmlixh4w32s7nk2uynvwggb6ajexbnexpvimslhzr.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitment.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitment({
              id: 'https://johnpatrickmorgan.github.io/2016/05/11/URLPatternMatching/',
              owner: 'johnpatrickmorgan',
              repo: 'johnpatrickmorgan.github.io',
              oauth: {
                client_id: 'c86c0ea73885f7f5bf5b',
                client_secret: 'f62a7e7c400e1dd6253c922492b76f9a4505dc27'
              }
            }).render('gitment')
          })()
        </script>
    




    </body>
</html>
