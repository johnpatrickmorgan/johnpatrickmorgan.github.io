
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="johnpatrickmorgan">
    <title>Improving SwiftUI Navigation for the Coordinator Pattern - johnpatrickmorgan</title>
    <meta name="author" content="John Patrick Morgan">
    
        <meta name="keywords" content="Swift,SwiftUI,iOS,swift,navigation,data-driven,coordinator">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"John Patrick Morgan","sameAs":["https://github.com/johnpatrickmorgan","https://twitter.com/jpmmusic"],"image":"MajorMorgan.jpg"},"articleBody":"In this post, we’ll explore how to manage SwiftUI navigation state with a single array. This will make it much simpler to hoist that state into a high-level view, and reap the benefits of the coordinator pattern.\n\n\n\nThe coordinator pattern has become very popular in the iOS community. It allows us to write isolated views that have zero knowledge of their context within an app. Navigation state is hoisted out of individual screens into a higher-level coordinator object, and this separation of concerns allows views to be more re-usable and testable.\nThe problemOn the other hand, SwiftUI gives us NavigationLink, which encourages the fragmentation of navigation state throughout various views in a navigation flow. NavigationLink also assumes that a particular screen in an app knows about the screens that follow it in the navigation flow: how to create them, when to push them onto the stack, and whether they should be presented or pushed. Further, NavigationLink assumes that any changes to the navigation stack are triggered by a user interaction. In reality, navigation state may need to change as a result of an API call, a deeplink, state restoration or a timer. All of this makes it difficult to implement the coordinator pattern in SwiftUI. \nThe goalIt would be ideal if we could manage navigation state in one place, as easily as managing an array - adding and removing views to trigger pushes and pops. Let’s explore what that might look like…\nThe first question is what type the array should be. If we want it to accept absolutely any type of view, it would have to be an array of AnyViews, but using AnyView is problematic: it impedes SwiftUI’s ability to track what’s changed and make efficient updates. Instead, let’s manage an array of screen identifiers, that we can use to create the corresponding views when we need them, e.g.:\n12345enum Screen &#123;    case homeView    case numberListView    case numberDetailView(Int)&#125;\n\nWith those defined, we can initialize an array of screens in our coordinator with @State var stack: [Screen] = [.homeView]. This array of screens will represent the screens in our navigation stack. Appending a screen will trigger a push, and dropping screens will trigger a pop. \nWe are going to need a translation layer to translate any changes we make to this stack array into something SwiftUI will understand - a hierarchy of views and NavigationLinks - and to update our stack whenever the user pops back. Let’s imagine we have a view that handles that translation, and we’ll call it NStack. It will need to accept a binding to the stack and a ViewBuilder closure that takes a Screen and returns the corresponding view. With that in place our coordinator might look like this:\n123456789101112131415161718192021222324252627282930struct AppCoordinator: View &#123;    @State var stack: [Screen] = [.homeView]        var body: some View &#123;        NavigationView &#123;            NavStack(stack: $stack) &#123; screen in                switch screen &#123;                case .homeView:                    HomeView(pickNumberTapped: showNumbers)                case .numberListView:                    NumberListView(numberSelected: showNumber)                case .numberDetailView(let number):                    NumberDetailView(number: number, cancel: pop)                &#125;            &#125;        &#125;    &#125;        private func showNumbers() &#123;        stack.append(.numberListView)    &#125;        private func showNumber(_ number: Int) &#123;        stack.append(.numberDetailView(number))    &#125;        private func pop() &#123;        stack = stack.dropLast()    &#125;&#125;\n\nWith this approach, navigation can be entirely driven by a single piece of state, managed by our coordinator. And each screen’s view can invoke a closure when a particular UI action is taken, requiring no knowledge of other screens in the flow. \nThe implementationNow let’s try to implement it. We have an array of Screens, but we need to translate that to a SwiftUI navigation stack: where the first view contains a link to the second, and the second view contains a link to the third etc. Described that way, SwiftUI’s navigation stack sounds a little like a Linked List, so let’s try and represent it that way:\n1234indirect enum NavigationNode&lt;ScreenView: View&gt; &#123;    case view(ScreenView, pushing: NavigationNode&lt;ScreenView&gt;)    case end&#125;\n\nEach navigation node is either a view that pushes another node, or the end of our list. The view case contains another NavigationNode as an associated value, so the list of nodes can continue for as long as we need. Because of this recursive definition, we need to mark the enum as indirect. Otherwise, it’s not clear how much memory a NavigationNode should take up, because it can grow to any size.\nNotice that all of the views in the list have the same type ScreenView. That might seem like a problem, since we want to be able to push different screen views. But ScreenView in this case is the result of the ViewBuilder closure passed to the NStack. Since this will typically be the result of a switch statement, ScreenView will be a conditional view type that could be any of the screen types we need to support. So NavigationNode is capable of representing a list of any number of views, each of which is one of the screens we support. This matches exactly what we can describe with our array of Screens.\nNow that we have our NavigationNode, let’s make it a View. It might seem unusual to make a SwiftUI view from an enum, as we’re used to using structs for that purpose, but an enum can work just as well:\n12345678910111213141516171819indirect enum NavigationNode&lt;ScreenView: View&gt;: View &#123;    case view(ScreenView, pushing: NavigationNode&lt;ScreenView&gt;)    case end        var body: some View &#123;        if case .view(let view, let pushedNode) = self &#123;            view                .background(                    NavigationLink(                        destination: pushedNode,                         isActive: .constant(true), // We&#x27;ll need to revisit this.                        label: EmptyView.init                    ).hidden()                )        &#125; else &#123;            EmptyView()        &#125;    &#125;&#125;\n\nIf the node is the end, we return an EmptyView. This should only be seen if our stack is empty. If the node is a view, we return the view, along with a NavigationLink in the background, which pushes the next node. The NavigationLink should be invisible so its label is an EmptyView, and it’s set to hidden(). The isActive binding is a little trickier, so we’ll come back to that.\nNext, let’s see if we can transform our array of screens into a NavigationNode representing the full stack. This is the job of our NStack, which we’ve already decided should take a binding to an array of Screens and a ViewBuilder closure to build a view for a given screen:\n1234struct NStack&lt;Screen, ScreenView: View&gt; &#123;    @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; ScreenView&#125;\n\nNow let’s make this NStack a view. We need to transform the array of screens into a NavigationNode. We’ll do so by starting with a NavigationNode.end and working backwards, with each new node pushing the node created by previous iterations:\n123456789101112131415struct NStack&lt;Screen, ScreenView: View&gt;: View &#123;    @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; ScreenView        var body: some View &#123;        stack            .reversed()            .reduce(NavigationNode&lt;ScreenView&gt;.end) &#123; pushedNode, screen in                return NavigationNode&lt;ScreenView&gt;.view(                    buildView(screen),                    pushing: pushedNode                )            &#125;    &#125;&#125;\n\nGreat. Now it’s time to turn our attention back to the NavigationNode and the isActive binding on its NavigationLink. This binding will be responsible for deciding if the next view should be pushed, and for updating the stack when the pushed view is popped back (e.g. if the user taps or swipes back). We’ll need a couple of extra parameters in order to do that, so we’ll amend the code above to additionally pass the stack binding and the node’s index when we create one:\n12345678910111213141516171819struct NStack&lt;Screen, ScreenView: View&gt;: View &#123;    @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; ScreenView        var body: some View &#123;        stack            .enumerated()            .reversed()            .reduce(NavigationNode&lt;Screen, ScreenView&gt;.end) &#123; pushedNode, new in                let (index, screen) = new                return NavigationNode&lt;Screen, ScreenView&gt;.view(                    buildView(screen),                    pushing: pushedNode,                    stack: $stack,                    index: index                )            &#125;    &#125;&#125;\n\nNow that the node has those values, we can use them to create the isActive binding for the NavigationLink. In the getter, we want to check that the stack’s count is higher than our index - if so, the view is being pushed, so we can return true. We also need to check that the pushedNode is not an end node, as we never want to push one of those. The setter is important, as that’s how we’ll be notified that the user has tapped the back button or swiped to go back. In the setter, we want to check if the new value is false. If so, then the user is navigating back. At this point we can truncate the stack so that the pushing view is at the top of the stack:\n123456789101112Binding(   get: &#123;       if case .end = pushedNode &#123;           return false       &#125;       return stack.wrappedValue.count &gt; index + 1   &#125;,   set: &#123; isPushed in       guard !isPushed else &#123; return &#125;       stack.wrappedValue = Array(stack.wrappedValue.prefix(index + 1))   &#125;)&#125;\n\nThat completes the translation layer between our desired API and what SwiftUI gives us: the coordinator code above now works as intended. All in all, it’s less than 50 lines of code. Here’s the implementation in full:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct NStack&lt;Screen, ScreenView: View&gt;: View &#123;    @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; ScreenView        var body: some View &#123;        stack            .enumerated()            .reversed()            .reduce(NavigationNode&lt;Screen, ScreenView&gt;.end) &#123; pushedNode, new in                let (index, screen) = new                return NavigationNode&lt;Screen, ScreenView&gt;.view(                    buildView(screen),                    pushing: pushedNode,                    stack: $stack,                    index: index                )            &#125;    &#125;&#125;indirect enum NavigationNode&lt;Screen, ScreenView: View&gt;: View &#123;    case view(ScreenView, pushing: NavigationNode&lt;Screen, ScreenView&gt;, stack: Binding&lt;[Screen]&gt;, index: Int)    case end        var body: some View &#123;        if case .view(let view, let pushedNode, let stack, let index) = self &#123;            view.background(                NavigationLink(                    destination: pushedNode,                    isActive: Binding(                        get: &#123;                            if case .end = pushedNode &#123;                                return false                            &#125;                            return stack.wrappedValue.count &gt; index + 1                        &#125;,                        set: &#123; isPushed in                            guard !isPushed else &#123; return &#125;                            stack.wrappedValue = Array(stack.wrappedValue.prefix(index + 1))                        &#125;),                    label: EmptyView.init                ).hidden()            )        &#125; else &#123;            EmptyView()        &#125;    &#125;&#125;\n\nEvaluating the solutionWe can now manage navigation with a single piece of state, rather than various pieces of state distributed among our views. Pushing new screens is as simple as stack.append(.newScreen), and if the user taps or swipes back, or uses the long press gesture to go further back, the navigation state will automatically get updated to reflect the change. Programmatically popping is as simple as stack = stack.dropLast(), and you can easily pop back to the root or to a specific screen, because the navigation stack can be examined at runtime.\nThe screen views themselves no longer need to have any knowledge of any other screens in the navigation flow - they can simply invoke a closure, e.g. with a Button, and leave the coordinator to decide what view, if any, should be pushed or presented.\nNot only does this make the coordinator pattern more at home in SwiftUI, it even has some advantages over the coordinator pattern in UIKit. With this approach, coordinators are just views, which means they can be composed and configured in all the normal ways views can. You can present a coordinator, add it to a TabView, or even push a child coordinator onto the navigation stack of a parent coordinator, just as you would a view. Note that NStack does not wrap its content in a NavigationView - that way, multiple coordinators can be nested within a single NavigationView. \nIn UIKit, child coordinators are a useful pattern, but some extra work is often required: e.g. to keep a strong reference to the child coordinator, pass it a UINavigationController or tell it to start(). None of that extra work is necessary in the SwiftUI version. The one caveat is that the child coordinator should only ever be the top view in its parent’s stack - as the parent passes navigation responsibilities to the child when it is pushed. \nNStack is available on GitHub. The library also includes a Stack object that acts as a thin wrapper around an array, adding some convenience methods for pushing and popping to a particular screen. You can see it in action, along with an example using view models, in the README. \nI’d love to hear your thoughts on whether this approach is useful and if it has any downsides I haven’t considered.\n&nbsp;\nAt the moment, SwiftUI does not support increasing the navigation stack by more than one in a single update. I’ve opened FB9200490 in the hope that this will be resolved.\n\n\n&nbsp;\n","dateCreated":"2021-07-03T21:10:39+01:00","dateModified":"2021-07-08T23:24:19+01:00","datePublished":"2021-07-03T21:10:39+01:00","description":"In this post, we’ll explore how to manage SwiftUI navigation state with a single array. This will make it much simpler to hoist that state into a high-level view, and reap the benefits of the coordinator pattern.","headline":"Improving SwiftUI Navigation for the Coordinator Pattern","image":["Signpost.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://johnpatrickmorgan.github.io/2021/07/03/NStack/"},"publisher":{"@type":"Organization","name":"John Patrick Morgan","sameAs":["https://github.com/johnpatrickmorgan","https://twitter.com/jpmmusic"],"image":"MajorMorgan.jpg","logo":{"@type":"ImageObject","url":"MajorMorgan.jpg"}},"url":"https://johnpatrickmorgan.github.io/2021/07/03/NStack/","keywords":"Swift, SwiftUI, Navigation, Coordinator","thumbnailUrl":"Signpost.jpg"}</script>
    <meta name="description" content="In this post, we’ll explore how to manage SwiftUI navigation state with a single array. This will make it much simpler to hoist that state into a high-level view, and reap the benefits of the coordina">
<meta property="og:type" content="blog">
<meta property="og:title" content="Improving SwiftUI Navigation for the Coordinator Pattern">
<meta property="og:url" content="https://johnpatrickmorgan.github.io/2021/07/03/NStack/index.html">
<meta property="og:site_name" content="johnpatrickmorgan">
<meta property="og:description" content="In this post, we’ll explore how to manage SwiftUI navigation state with a single array. This will make it much simpler to hoist that state into a high-level view, and reap the benefits of the coordina">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-07-03T20:10:39.000Z">
<meta property="article:modified_time" content="2021-07-08T22:24:19.966Z">
<meta property="article:author" content="John Patrick Morgan">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="SwiftUI">
<meta property="article:tag" content="Navigation">
<meta property="article:tag" content="Coordinator">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@jpmmusic">
    
    
        
    
    
        <meta property="og:image" content="https://johnpatrickmorgan.github.io/assets/images/MajorMorgan.jpg"/>
    
    
        <meta property="og:image" content="https://johnpatrickmorgan.github.io/2021/07/03/NStack/Signpost.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://johnpatrickmorgan.github.io/2021/07/03/NStack/Signpost.jpg"/>
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-epcsa1nqmtgul3o7hxuoq5zgbz1flaj2br28cifzmbm0aysxvypib8ntdnps.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78016335-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-78016335-1');
    </script>


    

    
        
            
<link rel="stylesheet" href="/assets/css/gitment.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            johnpatrickmorgan
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="3">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">John Patrick Morgan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Recovering Objective-C developer, one-time <a target="_blank" rel="noopener" href="http://www.johnpatrickmorgan.co.uk/">music composer</a>, now evolving with Swift.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/johnpatrickmorgan"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/jpmmusic"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Improving SwiftUI Navigation for the Coordinator Pattern
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2021-07-03T21:10:39+01:00">
	
		    Jul 03, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Swift/">Swift</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p><strong>In this post, we’ll explore how to manage SwiftUI navigation state with a single array. This will make it much simpler to hoist that state into a high-level view, and reap the benefits of the coordinator pattern.</strong></p>
<span id="more"></span>


<p>The <a target="_blank" rel="noopener" href="https://khanlou.com/2015/10/coordinators-redux/">coordinator pattern</a> has become very popular in the iOS community. It allows us to write isolated views that have zero knowledge of their context within an app. Navigation state is hoisted out of individual screens into a higher-level <em>coordinator</em> object, and this separation of concerns allows views to be more re-usable and testable.</p>
<h3 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem</h3><p>On the other hand, SwiftUI gives us <code>NavigationLink</code>, which encourages the fragmentation of navigation state throughout various views in a navigation flow. <code>NavigationLink</code> also assumes that a particular screen in an app knows about the screens that follow it in the navigation flow: how to create them, when to push them onto the stack, and whether they should be presented or pushed. Further, <code>NavigationLink</code> assumes that any changes to the navigation stack are triggered by a user interaction. In reality, navigation state may need to change as a result of an API call, a deeplink, state restoration or a timer. All of this makes it difficult to implement the coordinator pattern in SwiftUI. </p>
<h3 id="The-goal"><a href="#The-goal" class="headerlink" title="The goal"></a>The goal</h3><p><strong>It would be ideal if we could manage navigation state in one place, as easily as managing an array - adding and removing views to trigger pushes and pops. Let’s explore what that might look like…</strong></p>
<p>The first question is what type the array should be. If we want it to accept absolutely any type of view, it would have to be an array of <code>AnyView</code>s, but using <code>AnyView</code> is <a target="_blank" rel="noopener" href="https://www.swiftbysundell.com/articles/avoiding-anyview-in-swiftui/">problematic</a>: it impedes SwiftUI’s ability to track what’s changed and make efficient updates. Instead, let’s manage an array of screen identifiers, that we can use to create the corresponding views when we need them, e.g.:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> homeView</span><br><span class="line">    <span class="keyword">case</span> numberListView</span><br><span class="line">    <span class="keyword">case</span> numberDetailView(<span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With those defined, we can initialize an array of screens in our coordinator with <code>@State var stack: [Screen] = [.homeView]</code>. This array of screens will represent the screens in our navigation stack. Appending a screen will trigger a push, and dropping screens will trigger a pop. </p>
<p>We are going to need a translation layer to translate any changes we make to this <code>stack</code> array into something SwiftUI will understand - a hierarchy of views and <code>NavigationLink</code>s - and to update our stack whenever the user pops back. Let’s imagine we have a view that handles that translation, and we’ll call it <code>NStack</code>. It will need to accept a binding to the <code>stack</code> and a <code>ViewBuilder</code> closure that takes a <code>Screen</code> and returns the corresponding view. With that in place our coordinator might look like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppCoordinator</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>] <span class="operator">=</span> [.homeView]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">NavStack</span>(stack: <span class="variable">$stack</span>) &#123; screen <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> screen &#123;</span><br><span class="line">                <span class="keyword">case</span> .homeView:</span><br><span class="line">                    <span class="type">HomeView</span>(pickNumberTapped: showNumbers)</span><br><span class="line">                <span class="keyword">case</span> .numberListView:</span><br><span class="line">                    <span class="type">NumberListView</span>(numberSelected: showNumber)</span><br><span class="line">                <span class="keyword">case</span> .numberDetailView(<span class="keyword">let</span> number):</span><br><span class="line">                    <span class="type">NumberDetailView</span>(number: number, cancel: pop)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showNumbers</span>()</span> &#123;</span><br><span class="line">        stack.append(.numberListView)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showNumber</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        stack.append(.numberDetailView(number))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span>()</span> &#123;</span><br><span class="line">        stack <span class="operator">=</span> stack.dropLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With this approach, navigation can be entirely driven by a single piece of state, managed by our coordinator. And each screen’s view can invoke a closure when a particular UI action is taken, requiring no knowledge of other screens in the flow. </p>
<h3 id="The-implementation"><a href="#The-implementation" class="headerlink" title="The implementation"></a>The implementation</h3><p>Now let’s try to implement it. We have an array of <code>Screen</code>s, but we need to translate that to a SwiftUI navigation stack: where the first view contains a link to the second, and the second view contains a link to the third etc. Described that way, SwiftUI’s navigation stack sounds a little like a <em>Linked List</em>, so let’s try and represent it that way:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">NavigationNode</span>&lt;<span class="title">ScreenView</span>: <span class="title">View</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> view(<span class="type">ScreenView</span>, pushing: <span class="type">NavigationNode</span>&lt;<span class="type">ScreenView</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each navigation node is either a view that pushes another node, or the end of our list. The <code>view</code> case contains another <code>NavigationNode</code> as an associated value, so the list of nodes can continue for as long as we need. Because of this recursive definition, we need to mark the enum as <code>indirect</code>. Otherwise, it’s not clear how much memory a <code>NavigationNode</code> should take up, because it can grow to any size.</p>
<p>Notice that all of the views in the list have the same type <code>ScreenView</code>. That might seem like a problem, since we want to be able to push <em>different</em> screen views. But <code>ScreenView</code> in this case is the result of the <code>ViewBuilder</code> closure passed to the <code>NStack</code>. Since this will typically be the result of a switch statement, <code>ScreenView</code> will be a conditional view type that could be any of the screen types we need to support. So <code>NavigationNode</code> is capable of representing a list of any number of views, each of which is one of the screens we support. This matches exactly what we can describe with our array of <code>Screen</code>s.</p>
<p>Now that we have our <code>NavigationNode</code>, let’s make it a <code>View</code>. It might seem unusual to make a SwiftUI view from an enum, as we’re used to using structs for that purpose, but an enum can work just as well:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">NavigationNode</span>&lt;<span class="title">ScreenView</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> view(<span class="type">ScreenView</span>, pushing: <span class="type">NavigationNode</span>&lt;<span class="type">ScreenView</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> end</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> .view(<span class="keyword">let</span> view, <span class="keyword">let</span> pushedNode) <span class="operator">=</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            view</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">NavigationLink</span>(</span><br><span class="line">                        destination: pushedNode, </span><br><span class="line">                        isActive: .constant(<span class="literal">true</span>), <span class="comment">// We&#x27;ll need to revisit this.</span></span><br><span class="line">                        label: <span class="type">EmptyView</span>.<span class="keyword">init</span></span><br><span class="line">                    ).hidden()</span><br><span class="line">                )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">EmptyView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the node is the <code>end</code>, we return an <code>EmptyView</code>. This should only be seen if our stack is empty. If the node is a view, we return the view, along with a <code>NavigationLink</code> in the background, which pushes the next node. The <code>NavigationLink</code> should be invisible so its label is an <code>EmptyView</code>, and it’s set to <code>hidden()</code>. The <code>isActive</code> binding is a little trickier, so we’ll come back to that.</p>
<p>Next, let’s see if we can transform our array of screens into a <code>NavigationNode</code> representing the full stack. This is the job of our <code>NStack</code>, which we’ve already decided should take a binding to an array of <code>Screen</code>s and a <code>ViewBuilder</code> closure to build a view for a given screen:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">ScreenView</span>: <span class="title">View</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">ScreenView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s make this <code>NStack</code> a view. We need to transform the array of screens into a <code>NavigationNode</code>. We’ll do so by starting with a <code>NavigationNode.end</code> and working backwards, with each new node pushing the node created by previous iterations:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">ScreenView</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">ScreenView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        stack</span><br><span class="line">            .reversed()</span><br><span class="line">            .reduce(<span class="type">NavigationNode</span>&lt;<span class="type">ScreenView</span>&gt;.end) &#123; pushedNode, screen <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> <span class="type">NavigationNode</span>&lt;<span class="type">ScreenView</span>&gt;.view(</span><br><span class="line">                    buildView(screen),</span><br><span class="line">                    pushing: pushedNode</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Great. Now it’s time to turn our attention back to the <code>NavigationNode</code> and the <code>isActive</code> binding on its <code>NavigationLink</code>. This binding will be responsible for deciding if the next view should be pushed, and for updating the stack when the pushed view is popped back (e.g. if the user taps or swipes back). We’ll need a couple of extra parameters in order to do that, so we’ll amend the code above to additionally pass the stack binding and the node’s index when we create one:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">ScreenView</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">ScreenView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        stack</span><br><span class="line">            .enumerated()</span><br><span class="line">            .reversed()</span><br><span class="line">            .reduce(<span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">ScreenView</span>&gt;.end) &#123; pushedNode, new <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> (index, screen) <span class="operator">=</span> new</span><br><span class="line">                <span class="keyword">return</span> <span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">ScreenView</span>&gt;.view(</span><br><span class="line">                    buildView(screen),</span><br><span class="line">                    pushing: pushedNode,</span><br><span class="line">                    stack: <span class="variable">$stack</span>,</span><br><span class="line">                    index: index</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that the node has those values, we can use them to create the <code>isActive</code> binding for the <code>NavigationLink</code>. In the getter, we want to check that the stack’s count is higher than our index - if so, the view is being pushed, so we can return <code>true</code>. We also need to check that the <code>pushedNode</code> is not an <code>end</code> node, as we never want to push one of those. The setter is important, as that’s how we’ll be notified that the user has tapped the back button or swiped to go back. In the setter, we want to check if the new value is false. If so, then the user is navigating back. At this point we can truncate the stack so that the pushing view is at the top of the stack:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Binding</span>(</span><br><span class="line">   get: &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">case</span> .end <span class="operator">=</span> pushedNode &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.wrappedValue.count <span class="operator">&gt;</span> index <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   set: &#123; isPushed <span class="keyword">in</span></span><br><span class="line">       <span class="keyword">guard</span> <span class="operator">!</span>isPushed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">       stack.wrappedValue <span class="operator">=</span> <span class="type">Array</span>(stack.wrappedValue.prefix(index <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That completes the translation layer between our desired API and what SwiftUI gives us: the coordinator code above now works as intended. All in all, it’s less than 50 lines of code. Here’s the implementation in full:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">ScreenView</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">ScreenView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        stack</span><br><span class="line">            .enumerated()</span><br><span class="line">            .reversed()</span><br><span class="line">            .reduce(<span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">ScreenView</span>&gt;.end) &#123; pushedNode, new <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> (index, screen) <span class="operator">=</span> new</span><br><span class="line">                <span class="keyword">return</span> <span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">ScreenView</span>&gt;.view(</span><br><span class="line">                    buildView(screen),</span><br><span class="line">                    pushing: pushedNode,</span><br><span class="line">                    stack: <span class="variable">$stack</span>,</span><br><span class="line">                    index: index</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">NavigationNode</span>&lt;<span class="title">Screen</span>, <span class="title">ScreenView</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> view(<span class="type">ScreenView</span>, pushing: <span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">ScreenView</span>&gt;, stack: <span class="type">Binding</span>&lt;[<span class="type">Screen</span>]&gt;, index: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> end</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> .view(<span class="keyword">let</span> view, <span class="keyword">let</span> pushedNode, <span class="keyword">let</span> stack, <span class="keyword">let</span> index) <span class="operator">=</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            view.background(</span><br><span class="line">                <span class="type">NavigationLink</span>(</span><br><span class="line">                    destination: pushedNode,</span><br><span class="line">                    isActive: <span class="type">Binding</span>(</span><br><span class="line">                        get: &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">case</span> .end <span class="operator">=</span> pushedNode &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> stack.wrappedValue.count <span class="operator">&gt;</span> index <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        set: &#123; isPushed <span class="keyword">in</span></span><br><span class="line">                            <span class="keyword">guard</span> <span class="operator">!</span>isPushed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                            stack.wrappedValue <span class="operator">=</span> <span class="type">Array</span>(stack.wrappedValue.prefix(index <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line">                        &#125;),</span><br><span class="line">                    label: <span class="type">EmptyView</span>.<span class="keyword">init</span></span><br><span class="line">                ).hidden()</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">EmptyView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Evaluating-the-solution"><a href="#Evaluating-the-solution" class="headerlink" title="Evaluating the solution"></a>Evaluating the solution</h3><p>We can now manage navigation with a single piece of state, rather than various pieces of state distributed among our views. Pushing new screens is as simple as <code>stack.append(.newScreen)</code>, and if the user taps or swipes back, or uses the long press gesture to go further back, the navigation state will automatically get updated to reflect the change. Programmatically popping is as simple as <code>stack = stack.dropLast()</code>, and you can easily pop back to the root or to a specific screen, because the navigation stack can be examined at runtime.</p>
<p>The screen views themselves no longer need to have any knowledge of any other screens in the navigation flow - they can simply invoke a closure, e.g. with a <code>Button</code>, and leave the coordinator to decide what view, if any, should be pushed or presented.</p>
<p>Not only does this make the coordinator pattern more at home in SwiftUI, it even has some advantages over the coordinator pattern in UIKit. With this approach, coordinators are just views, which means they can be composed and configured in all the normal ways views can. You can present a coordinator, add it to a <code>TabView</code>, or even push a child coordinator onto the navigation stack of a parent coordinator, just as you would a view. Note that <code>NStack</code> does not wrap its content in a <code>NavigationView</code> - that way, multiple coordinators can be nested within a single <code>NavigationView</code>. </p>
<p>In UIKit, child coordinators are a useful pattern, but some extra work is often required: e.g. to keep a strong reference to the child coordinator, pass it a <code>UINavigationController</code> or tell it to <code>start()</code>. None of that extra work is necessary in the SwiftUI version. The one caveat is that the child coordinator should only ever be the top view in its parent’s stack - as the parent passes navigation responsibilities to the child when it is pushed. </p>
<p><code>NStack</code> is available on <a target="_blank" rel="noopener" href="https://github.com/johnpatrickmorgan/NStack">GitHub</a>. The library also includes a <code>Stack</code> object that acts as a thin wrapper around an array, adding some convenience methods for pushing and popping to a particular screen. You can see it in action, along with an example using view models, in the <a target="_blank" rel="noopener" href="https://github.com/johnpatrickmorgan/NStack#using-view-models">README</a>. </p>
<p>I’d love to hear your thoughts on whether this approach is useful and if it has any downsides I haven’t considered.</p>
<p>&nbsp;</p>
<div class="alert info"><p>At the moment, SwiftUI does not support increasing the navigation stack by more than one in a single update. I’ve opened <code>FB9200490</code> in the hope that this will be resolved.</p>
</div>

<p>&nbsp;</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Coordinator/" rel="tag">Coordinator</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Navigation/" rel="tag">Navigation</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Swift/" rel="tag">Swift</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/SwiftUI/" rel="tag">SwiftUI</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2016/05/11/URLPatternMatching/"
                    data-tooltip="URL Pattern Matching"
                    aria-label="NEXT: URL Pattern Matching"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitment"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitment"></div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyright &copy; 2021 John Patrick Morgan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2016/05/11/URLPatternMatching/"
                    data-tooltip="URL Pattern Matching"
                    aria-label="NEXT: URL Pattern Matching"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitment"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="3">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">John Patrick Morgan</h4>
        
            <div id="about-card-bio"><p>Recovering Objective-C developer, one-time <a target="_blank" rel="noopener" href="http://www.johnpatrickmorgan.co.uk/">music composer</a>, now evolving with Swift.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p><a target="_blank" rel="noopener" href="https://joinzoe.com/">ZOE</a></p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                London
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-dli0zl8vd3wl2erskfanmlixh4w32s7nk2uynvwggb6ajexbnexpvimslhzr.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitment.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitment({
              id: '2021/07/03/NStack/',
              owner: 'johnpatrickmorgan',
              repo: 'johnpatrickmorgan.github.io',
              oauth: {
                client_id: 'c86c0ea73885f7f5bf5b',
                client_secret: 'f62a7e7c400e1dd6253c922492b76f9a4505dc27'
              }
            }).render('gitment')
          })()
        </script>
    




    </body>
</html>
