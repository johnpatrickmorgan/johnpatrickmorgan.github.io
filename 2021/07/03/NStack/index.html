
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="johnpatrickmorgan">
    <title>Improving SwiftUI Navigation with Coordinators - johnpatrickmorgan</title>
    <meta name="author" content="John Patrick Morgan">
    
        <meta name="keywords" content="Swift,SwiftUI,iOS,swift,navigation,data-driven,coordinator">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"John Patrick Morgan","sameAs":["https://github.com/johnpatrickmorgan","https://twitter.com/jpmmusic"],"image":"MajorMorgan.jpg"},"articleBody":"When it comes to pushing and popping views on a navigation stack, SwiftUI offers us a single tool: NavigationLink. Sadly, its design doesn’t play very nicely with the coordinator pattern. But with very little code, we can translate SwiftUI’s navigation into a format that fits the coordinator pattern very well. \n\n\n\nThe coordinator pattern has become very popular in the iOS community. It allows you to write isolated views that have zero knowledge of their context within an app. Navigation state is hoisted out of individual screens into a higher-level coordinator object, and this separation of concerns allows views to be more re-usable and testable.\nThe problemIn contrast, NavigationLink encourages the fragmentation of navigation state throughout various views in a navigation flow. NavigationLink also assumes that a particular screen in an app knows about the screens that follow it in the navigation flow: how to create them, when to push them onto the stack, and whether they should be presented or pushed. Finally, NavigationLink assumes that any changes to the navigation stack are triggered immediately by a user interaction. In reality, navigation state may need to change as a result of an API call, a deeplink, state restoration or a timer. All of this makes it difficult to implement the coordinator pattern in SwiftUI. \n\n\nThe goalIt would be great if we could manage navigation state in one place, as easily as managing an array - adding and removing views to trigger pushes and pops. Let’s work towards that goal…\nThe first problem is what type the array should be. If we want it to accept any type of view, it would have to be an array of AnyViews, but using AnyView is problematic: it impedes SwiftUI’s ability to track what’s changed and make efficient updates. Instead, let’s manage an array of screen identifiers, that we can use to create the corresponding views when we need them, e.g.:\n12345enum Screen &#123;    case homeView    case numberListView    case numberView(Int)&#125;\n\nWith those defined, we can initialize an array in our coordinator with @State var stack: [Screen] = [.homeView]. Now, we are going to need a translation layer to translate any changes we make to this stack array into something SwiftUI will understand - a hierarchy of views and NavigationLinks - and to update our stack whenever the user pops back. Let’s imagine we have a view that handles that translation, and we’ll call it NStack. It will need to accept a binding to the stack and a ViewBuilder closure that takes a Screen and returns the corresponding view. With that in place our coordinator might look like this:\n1234567891011121314151617181920212223242526272829303132333435struct AppCoordinator: View &#123;    @State var stack: [Screen] = [.homeView]        var body: some View &#123;        NavigationView &#123;            NavStack(stack: $stack) &#123; screen in                switch screen &#123;                case .homeView:                    HomeView(pickNumberTapped: showNumbers)                case .numberListView:                    NumberListView(numberSelected: showNumber)                case .numberView(let number):                    NumberView(number: number, cancel: popToRoot)                &#125;            &#125;        &#125;    &#125;        private func showNumbers() &#123;        stack.append(.numberListView)    &#125;        private func showNumber(_ number: Int) &#123;        stack.append(.numberView(number))    &#125;        private func pop() &#123;        stack = stack.dropLast()    &#125;        private func popToRoot() &#123;        stack = [.homeView]    &#125;&#125;\n\nWith this approach, navigation can be entirely driven by a single piece of state, managed by our coordinator. And each screen’s view can invoke a closure when a particular UI action is taken (or API response is received, timer fired etc.), requiring no knowledge of other screens in the flow. \nThe implementationNow let’s try to implement it. We have an array of Screens, but we need to translate that to a SwiftUI navigation stack: where the first view contains a link to the second, and the second view contains a link to the third etc. Described that way, SwiftUI’s navigation stack sounds a little like a Linked List, so let’s try and represent it that way:\n12345indirect enum NavigationNode&lt;V: View&gt; &#123;        case view(V, pushing: NavigationNode&lt;V&gt;)    case end&#125;\n\nEach node is either a view that pushes another node, or the end of our list. The view case contains another NavigationNode as an associated value, so the list of nodes can continue for as long as we need. Because of this recursive definition, we need to mark the enum as indirect. Otherwise, it’s not clear how much memory a NavigationNode should take up, because it can grow to any size.\nNotice that all of the views in the list have the same type V. That might seem like a problem, since we want to be able to push different screen views. But V in this case will be the result of the ViewBuilder closure passed to the NStack - a conditional view type that could be any of the screen types we need to support. So NavigationNode is capable of representing a list of any number of views, each of which is one of the screens we support. This matches exactly what we can describe with our array of Screens.\nNow that we have our NavigationNode, let’s make it a View. It might seem unusual to make a SwiftUI view from an enum, as we’re used to using structs for that purpose, but an enum can work just as well:\n1234567891011121314151617181920indirect enum NavigationNode&lt;V: View&gt;: View &#123;        case view(V, pushing: NavigationNode&lt;V&gt;)    case end        var body: some View &#123;        if case .view(let view, let pushedView) = self &#123;            ZStack &#123;                NavigationLink(                    destination: pushedView,                    isActive: .constant(true), // We&#x27;ll need to revisit this.                    label: &#123; EmptyView() &#125;                ).hidden()                view            &#125;        &#125; else &#123;            EmptyView()        &#125;    &#125;&#125;\n\nIf the node is the end, we return an EmptyView. This should only be seen if our stack is empty. If the node is a view, we embed the view in a ZStack, alongside a NavigationLink which pushes the next node. The NavigationLink should be invisible so its label is an EmptyView, and it’s set to hidden(). \nNext, let’s see if we can transform our array of screens into a NavigationNode representing the full stack. This is the job of our NStack, which we’ve already decided should take a binding to an array of Screens and a ViewBuilder closure to build a view for a given screen:\n12345struct NStack&lt;Screen, V: View&gt; &#123;        @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; V&#125;\n\nNow let’s make this NStack a view. We need to transform the array of screens into a NavigationNode. We’ll do so by starting with a NavigationNode.end and working backwards, with each new node pushing the node created by previous iterations:\n1234567891011121314151617struct NStack&lt;Screen, V: View&gt;: View &#123;        @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; V        var body: some View &#123;        stack            .reversed()            .reduce(NavigationNode&lt;V&gt;.end) &#123; pushedView, new in                let (index, screen) = new                return NavigationNode&lt;V&gt;.view(                    buildView(screen),                    pushing: pushedView                )            &#125;    &#125;&#125;\n\nGreat. Now it’s time to turn our attention back to the NavigationNode and the isActive binding on its NavigationLink. This binding will be responsible for deciding if the next view should be pushed, and for updating the stack when the pushed view is popped back (e.g. by the user tapping or swiping back). We will need a couple of extra parameters in order to do that, so we’ll amend the code above to pass the stack binding and the node’s index when we create one:\n1234567891011121314151617181920struct NStack&lt;Screen, V: View&gt;: View &#123;        @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; V        var body: some View &#123;        stack            .enumerated()            .reversed()            .reduce(NavigationNode&lt;Screen, V&gt;.end) &#123; pushedView, new in                let (index, screen) = new                return NavigationNode&lt;Screen, V&gt;.view(                    buildView(screen),                    pushing: pushedView,                    stack: $stack,                    index: index                )            &#125;    &#125;&#125;\n\nNow that the node has those values, we can use them to create the isActive binding for the NavigationLink. In the getter, we want to check that the stack’s count is higher than our index - if so, the view is being pushed, so we can return true. We also need to check that the pushedView is not an end node, as we never want to push one of those. The setter is important, as that’s how we’ll be notified that the user has tapped the back button or swiped to go back. In the setter, we want to check if the new value is false. If so, then the user has tapped back. At this point we can truncate the stack so that the pushing view is at the top of the stack.\n123456789101112Binding(   get: &#123;       if case .end = pushedView &#123;           return false       &#125;       return stack.wrappedValue.count &gt; index   &#125;,   set: &#123; isPushed in       guard !isPushed else &#123; return &#125;       stack.wrappedValue = Array(stack.wrappedValue.prefix(index + 1))   &#125;)&#125;\n\nWith that in place, we’ve successfully implemented our desired API. Here’s the implementation code in full:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct NStack&lt;Screen, V: View&gt;: View &#123;        @Binding var stack: [Screen]    @ViewBuilder var buildView: (Screen) -&gt; V        var body: some View &#123;        stack            .enumerated()            .reversed()            .reduce(NavigationNode&lt;Screen, V&gt;.unlinked) &#123; pushedView, new in                let (index, screen) = new                return NavigationNode&lt;Screen, V&gt;.linked(                    view: buildView(screen),                    pushing: pushedView,                    stack: $stack,                    index: index                )            &#125;    &#125;&#125;indirect enum NavigationNode&lt;Screen, V: View&gt;: View &#123;        case linked(view: V, pushing: NavigationNode&lt;Screen, V&gt;, stack: Binding&lt;[Screen]&gt;, index: Int)    case unlinked        var body: some View &#123;        if case .linked(let view, let pushedView, let stack, let index) = self &#123;            ZStack &#123;                NavigationLink(                    destination: pushedView,                    isActive: Binding(                        get: &#123;                            if case .unlinked = pushedView &#123;                                return false                            &#125;                            return stack.wrappedValue.count &gt; index                        &#125;,                        set: &#123; isPushed in                            guard !isPushed else &#123; return &#125;                            stack.wrappedValue = Array(stack.wrappedValue.prefix(index + 1))                        &#125;),                    label: &#123; EmptyView() &#125;                )                view            &#125;        &#125; else &#123;            EmptyView()        &#125;    &#125;&#125;\n\nEvaluating the solutionWe can now manage navigation with a single piece of state, rather than various pieces of state distributed among our views. Pushing new screens is as simple as stack.append(.newScreen), and if the user taps or swipes back, or uses the long press gesture to go further back, the navigation state will automatically get updated to reflect the change. Programmatically popping is as simple as stack = stack.dropLast(), and you can easily pop back to the root or to a specific screen, because the navigation stack can be examined at runtime.\nThe screen views themselves no longer need to have any knowledge of any other screens in the navigation flow - they can simply invoke a closure after any event (e.g. a button tap, API response, timer etc.) and leave the coordinator to decide what view, if any, should be pushed or presented.\nNot only does this make the coordinator pattern more at home in SwiftUI, it even has some advantages over the coordinator pattern in UIKit. With this approach, coordinators are just views, which means they can be composed and configured in all the normal ways views can. You can present a coordinator, add it to a TabView, or even push a child coordinator onto the navigation stack of a parent coordinator. In UIKit, child coordinators are a useful pattern, but some extra work is often required: e.g. to keep a strong reference to the child coordinator, pass it a UINavigationController and tell it to start(). None of that extra work is necessary in the SwiftUI version. The one caveat is that the child coordinator should only ever be the top view in its parent’s stack - as the parent passes navigation responsibilities to the child when it is pushed.\n\n\nIn the example above the state was held by the coordinator itself, but the approach works equally well if you prefer to use view models. Here’s an idea of how the example above might be re-written with view models:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344class AppCoordinatorViewModel: ObservableObject &#123;        @Published var stack = Stack&lt;Screen&gt;()        init() &#123;        stack.push(.home(.init(onGoTapped: showNumberList)))    &#125;        private func showNumberList() &#123;        stack.push(.numberList(.init(onNumberSelected: showNumber, cancel: pop)))    &#125;        private func showNumber(_ number: Int) &#123;        stack.push(.number(.init(number: number, cancel: popToRoot)))    &#125;        private func pop() &#123;        stack.pop()    &#125;        private func popToRoot() &#123;        stack.popToRoot()    &#125;&#125;struct AppCoordinator: View &#123;        @ObservedObject var viewModel = AppCoordinatorViewModel()        var body: some View &#123;        NavigationView &#123;            NStack(stack: $viewModel.stack) &#123; screen in                switch screen &#123;                case .home(let viewModel):                    HomeView(viewModel: viewModel)                case .numberList(let viewModel):                    NumberListView(viewModel: viewModel)                case .number(let viewModel):                    NumberView(viewModel: viewModel)                &#125;            &#125;        &#125;    &#125;&#125;\n\nNStack is available on GitHub. The library also includes a Stack object that acts as a thin wrapper around an array, adding some convenience methods for pushing and popping to a particular screen. You can see it in action in the view model example above. \nI’d love to hear your thoughts on whether this approach is useful and if it has any downsides I haven’t considered.\nOne word of warning: at the moment, SwiftUI does not support increasing the navigation stack by more than one in a single update. I’ve opened FB9200490 in the hope that this will be resolved.\n\n","dateCreated":"2021-07-03T21:10:39+01:00","dateModified":"2021-07-02T22:23:50+01:00","datePublished":"2021-07-03T21:10:39+01:00","description":"When it comes to pushing and popping views on a navigation stack, SwiftUI offers us a single tool: NavigationLink. Sadly, its design doesn’t play very nicely with the coordinator pattern. But with very little code, we can translate SwiftUI’s navigation into a format that fits the coordinator pattern very well. ","headline":"Improving SwiftUI Navigation with Coordinators","image":["Signpost.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://johnpatrickmorgan.github.io/2021/07/03/NStack/"},"publisher":{"@type":"Organization","name":"John Patrick Morgan","sameAs":["https://github.com/johnpatrickmorgan","https://twitter.com/jpmmusic"],"image":"MajorMorgan.jpg","logo":{"@type":"ImageObject","url":"MajorMorgan.jpg"}},"url":"https://johnpatrickmorgan.github.io/2021/07/03/NStack/","keywords":"Swift, SwiftUI, Navigation, Coordinator","thumbnailUrl":"Signpost.jpg"}</script>
    <meta name="description" content="When it comes to pushing and popping views on a navigation stack, SwiftUI offers us a single tool: NavigationLink. Sadly, its design doesn’t play very nicely with the coordinator pattern. But with ver">
<meta property="og:type" content="blog">
<meta property="og:title" content="Improving SwiftUI Navigation with Coordinators">
<meta property="og:url" content="https://johnpatrickmorgan.github.io/2021/07/03/NStack/index.html">
<meta property="og:site_name" content="johnpatrickmorgan">
<meta property="og:description" content="When it comes to pushing and popping views on a navigation stack, SwiftUI offers us a single tool: NavigationLink. Sadly, its design doesn’t play very nicely with the coordinator pattern. But with ver">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-07-03T20:10:39.000Z">
<meta property="article:modified_time" content="2021-07-02T21:23:50.569Z">
<meta property="article:author" content="John Patrick Morgan">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="SwiftUI">
<meta property="article:tag" content="Navigation">
<meta property="article:tag" content="Coordinator">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@jpmmusic">
    
    
        
    
    
        <meta property="og:image" content="https://johnpatrickmorgan.github.io/assets/images/MajorMorgan.jpg"/>
    
    
        <meta property="og:image" content="https://johnpatrickmorgan.github.io/2021/07/03/NStack/Signpost.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://johnpatrickmorgan.github.io/2021/07/03/NStack/Signpost.jpg"/>
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-ze2m4c6d8dr8ixg82bg0ehfyp1ffyl42qqqete264uvwkjmhprjfxvmcfkt4.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78016335-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-78016335-1');
    </script>


    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            johnpatrickmorgan
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="3">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">John Patrick Morgan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Recovering Objective-C developer, one-time <a target="_blank" rel="noopener" href="http://www.johnpatrickmorgan.co.uk/">music composer</a>, now evolving with Swift.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/johnpatrickmorgan"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/jpmmusic"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Improving SwiftUI Navigation with Coordinators
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2021-07-03T21:10:39+01:00">
	
		    Jul 03, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Swift/">Swift</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>When it comes to pushing and popping views on a navigation stack, SwiftUI offers us a single tool: <code>NavigationLink</code>. Sadly, its design doesn’t play very nicely with the coordinator pattern. But with very little code, we can translate SwiftUI’s navigation into a format that fits the coordinator pattern very well. </p>
<span id="more"></span>


<p>The <a target="_blank" rel="noopener" href="https://khanlou.com/2015/10/coordinators-redux/">coordinator pattern</a> has become very popular in the iOS community. It allows you to write isolated views that have zero knowledge of their context within an app. Navigation state is hoisted out of individual screens into a higher-level coordinator object, and this separation of concerns allows views to be more re-usable and testable.</p>
<h3 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem</h3><p>In contrast, <code>NavigationLink</code> encourages the fragmentation of navigation state throughout various views in a navigation flow. <code>NavigationLink</code> also assumes that a particular screen in an app knows about the screens that follow it in the navigation flow: how to create them, when to push them onto the stack, and whether they should be presented or pushed. Finally, <code>NavigationLink</code> assumes that any changes to the navigation stack are triggered immediately by a user interaction. In reality, navigation state may need to change as a result of an API call, a deeplink, state restoration or a timer. All of this makes it difficult to implement the coordinator pattern in SwiftUI. </p>
<!-- There are some workarounds for these issues, but I'm looking for one that meets these requirements:
- It shouldn't resort to using UIKit. It should be a SwiftUI solution.
- It shouldn't rely on erasing views to `AnyView`, as that can impair SwiftUI's performance.
- It shouldn't rewrite `UINavigationController` from scratch.


- Views should be completely isolated from the fact that views will be pushed or presented as a result of 
- It shouldn't fragment navigation state into multiple 
- Some use generics to abstract away the type of view that will be pushed, but the pushing view still needs to know that a view...
 -->

<h3 id="The-goal"><a href="#The-goal" class="headerlink" title="The goal"></a>The goal</h3><p><em>It would be great if we could manage navigation state in one place, as easily as managing an array - adding and removing views to trigger pushes and pops. Let’s work towards that goal…</em></p>
<p>The first problem is what type the array should be. If we want it to accept any type of view, it would have to be an array of <code>AnyView</code>s, but using <code>AnyView</code> is problematic: it impedes SwiftUI’s ability to track what’s changed and make efficient updates. Instead, let’s manage an array of screen identifiers, that we can use to create the corresponding views when we need them, e.g.:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> homeView</span><br><span class="line">    <span class="keyword">case</span> numberListView</span><br><span class="line">    <span class="keyword">case</span> numberView(<span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With those defined, we can initialize an array in our coordinator with <code>@State var stack: [Screen] = [.homeView]</code>. Now, we are going to need a translation layer to translate any changes we make to this <code>stack</code> array into something SwiftUI will understand - a hierarchy of views and <code>NavigationLink</code>s - and to update our stack whenever the user pops back. Let’s imagine we have a view that handles that translation, and we’ll call it <code>NStack</code>. It will need to accept a binding to the <code>stack</code> and a <code>ViewBuilder</code> closure that takes a <code>Screen</code> and returns the corresponding view. With that in place our coordinator might look like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppCoordinator</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>] <span class="operator">=</span> [.homeView]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">NavStack</span>(stack: <span class="variable">$stack</span>) &#123; screen <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> screen &#123;</span><br><span class="line">                <span class="keyword">case</span> .homeView:</span><br><span class="line">                    <span class="type">HomeView</span>(pickNumberTapped: showNumbers)</span><br><span class="line">                <span class="keyword">case</span> .numberListView:</span><br><span class="line">                    <span class="type">NumberListView</span>(numberSelected: showNumber)</span><br><span class="line">                <span class="keyword">case</span> .numberView(<span class="keyword">let</span> number):</span><br><span class="line">                    <span class="type">NumberView</span>(number: number, cancel: popToRoot)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showNumbers</span>()</span> &#123;</span><br><span class="line">        stack.append(.numberListView)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showNumber</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        stack.append(.numberView(number))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span>()</span> &#123;</span><br><span class="line">        stack <span class="operator">=</span> stack.dropLast()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">popToRoot</span>()</span> &#123;</span><br><span class="line">        stack <span class="operator">=</span> [.homeView]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With this approach, navigation can be entirely driven by a single piece of state, managed by our coordinator. And each screen’s view can invoke a closure when a particular UI action is taken (or API response is received, timer fired etc.), requiring no knowledge of other screens in the flow. </p>
<h3 id="The-implementation"><a href="#The-implementation" class="headerlink" title="The implementation"></a>The implementation</h3><p>Now let’s try to implement it. We have an array of <code>Screen</code>s, but we need to translate that to a SwiftUI navigation stack: where the first view contains a link to the second, and the second view contains a link to the third etc. Described that way, SwiftUI’s navigation stack sounds a little like a Linked List, so let’s try and represent it that way:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">NavigationNode</span>&lt;<span class="title">V</span>: <span class="title">View</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> view(<span class="type">V</span>, pushing: <span class="type">NavigationNode</span>&lt;<span class="type">V</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each node is either a view that pushes another node, or the end of our list. The <code>view</code> case contains another <code>NavigationNode</code> as an associated value, so the list of nodes can continue for as long as we need. Because of this recursive definition, we need to mark the enum as <code>indirect</code>. Otherwise, it’s not clear how much memory a <code>NavigationNode</code> should take up, because it can grow to any size.</p>
<p>Notice that all of the views in the list have the same type <code>V</code>. That might seem like a problem, since we want to be able to push <em>different</em> screen views. But <code>V</code> in this case will be the result of the <code>ViewBuilder</code> closure passed to the <code>NStack</code> - a conditional view type that could be any of the screen types we need to support. So <code>NavigationNode</code> is capable of representing a list of any number of views, each of which is one of the screens we support. This matches exactly what we can describe with our array of <code>Screen</code>s.</p>
<p>Now that we have our <code>NavigationNode</code>, let’s make it a <code>View</code>. It might seem unusual to make a SwiftUI view from an enum, as we’re used to using structs for that purpose, but an enum can work just as well:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">NavigationNode</span>&lt;<span class="title">V</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> view(<span class="type">V</span>, pushing: <span class="type">NavigationNode</span>&lt;<span class="type">V</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> end</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> .view(<span class="keyword">let</span> view, <span class="keyword">let</span> pushedView) <span class="operator">=</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="type">ZStack</span> &#123;</span><br><span class="line">                <span class="type">NavigationLink</span>(</span><br><span class="line">                    destination: pushedView,</span><br><span class="line">                    isActive: .constant(<span class="literal">true</span>), <span class="comment">// We&#x27;ll need to revisit this.</span></span><br><span class="line">                    label: &#123; <span class="type">EmptyView</span>() &#125;</span><br><span class="line">                ).hidden()</span><br><span class="line">                view</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">EmptyView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the node is the <code>end</code>, we return an <code>EmptyView</code>. This should only be seen if our stack is empty. If the node is a view, we embed the view in a <code>ZStack</code>, alongside a <code>NavigationLink</code> which pushes the next node. The <code>NavigationLink</code> should be invisible so its label is an <code>EmptyView</code>, and it’s set to <code>hidden()</code>. </p>
<p>Next, let’s see if we can transform our array of screens into a <code>NavigationNode</code> representing the full stack. This is the job of our <code>NStack</code>, which we’ve already decided should take a binding to an array of <code>Screen</code>s and a <code>ViewBuilder</code> closure to build a view for a given screen:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">V</span>: <span class="title">View</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">V</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s make this <code>NStack</code> a view. We need to transform the array of screens into a <code>NavigationNode</code>. We’ll do so by starting with a <code>NavigationNode.end</code> and working backwards, with each new node pushing the node created by previous iterations:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">V</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">V</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        stack</span><br><span class="line">            .reversed()</span><br><span class="line">            .reduce(<span class="type">NavigationNode</span>&lt;<span class="type">V</span>&gt;.end) &#123; pushedView, new <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> (index, screen) <span class="operator">=</span> new</span><br><span class="line">                <span class="keyword">return</span> <span class="type">NavigationNode</span>&lt;<span class="type">V</span>&gt;.view(</span><br><span class="line">                    buildView(screen),</span><br><span class="line">                    pushing: pushedView</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Great. Now it’s time to turn our attention back to the <code>NavigationNode</code> and the <code>isActive</code> binding on its <code>NavigationLink</code>. This binding will be responsible for deciding if the next view should be pushed, and for updating the stack when the pushed view is popped back (e.g. by the user tapping or swiping back). We will need a couple of extra parameters in order to do that, so we’ll amend the code above to pass the stack binding and the node’s index when we create one:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">V</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">V</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        stack</span><br><span class="line">            .enumerated()</span><br><span class="line">            .reversed()</span><br><span class="line">            .reduce(<span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">V</span>&gt;.end) &#123; pushedView, new <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> (index, screen) <span class="operator">=</span> new</span><br><span class="line">                <span class="keyword">return</span> <span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">V</span>&gt;.view(</span><br><span class="line">                    buildView(screen),</span><br><span class="line">                    pushing: pushedView,</span><br><span class="line">                    stack: <span class="variable">$stack</span>,</span><br><span class="line">                    index: index</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that the node has those values, we can use them to create the <code>isActive</code> binding for the <code>NavigationLink</code>. In the getter, we want to check that the stack’s count is higher than our index - if so, the view is being pushed, so we can return <code>true</code>. We also need to check that the pushedView is not an <code>end</code> node, as we never want to push one of those. The setter is important, as that’s how we’ll be notified that the user has tapped the back button or swiped to go back. In the setter, we want to check if the new value is false. If so, then the user has tapped back. At this point we can truncate the stack so that the pushing view is at the top of the stack.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Binding</span>(</span><br><span class="line">   get: &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">case</span> .end <span class="operator">=</span> pushedView &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.wrappedValue.count <span class="operator">&gt;</span> index</span><br><span class="line">   &#125;,</span><br><span class="line">   set: &#123; isPushed <span class="keyword">in</span></span><br><span class="line">       <span class="keyword">guard</span> <span class="operator">!</span>isPushed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">       stack.wrappedValue <span class="operator">=</span> <span class="type">Array</span>(stack.wrappedValue.prefix(index <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that in place, we’ve successfully implemented our desired API. Here’s the implementation code in full:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NStack</span>&lt;<span class="title">Screen</span>, <span class="title">V</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> stack: [<span class="type">Screen</span>]</span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> buildView: (<span class="type">Screen</span>) -&gt; <span class="type">V</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        stack</span><br><span class="line">            .enumerated()</span><br><span class="line">            .reversed()</span><br><span class="line">            .reduce(<span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">V</span>&gt;.unlinked) &#123; pushedView, new <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> (index, screen) <span class="operator">=</span> new</span><br><span class="line">                <span class="keyword">return</span> <span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">V</span>&gt;.linked(</span><br><span class="line">                    view: buildView(screen),</span><br><span class="line">                    pushing: pushedView,</span><br><span class="line">                    stack: <span class="variable">$stack</span>,</span><br><span class="line">                    index: index</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">NavigationNode</span>&lt;<span class="title">Screen</span>, <span class="title">V</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> linked(view: <span class="type">V</span>, pushing: <span class="type">NavigationNode</span>&lt;<span class="type">Screen</span>, <span class="type">V</span>&gt;, stack: <span class="type">Binding</span>&lt;[<span class="type">Screen</span>]&gt;, index: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> unlinked</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> .linked(<span class="keyword">let</span> view, <span class="keyword">let</span> pushedView, <span class="keyword">let</span> stack, <span class="keyword">let</span> index) <span class="operator">=</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="type">ZStack</span> &#123;</span><br><span class="line">                <span class="type">NavigationLink</span>(</span><br><span class="line">                    destination: pushedView,</span><br><span class="line">                    isActive: <span class="type">Binding</span>(</span><br><span class="line">                        get: &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">case</span> .unlinked <span class="operator">=</span> pushedView &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> stack.wrappedValue.count <span class="operator">&gt;</span> index</span><br><span class="line">                        &#125;,</span><br><span class="line">                        set: &#123; isPushed <span class="keyword">in</span></span><br><span class="line">                            <span class="keyword">guard</span> <span class="operator">!</span>isPushed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                            stack.wrappedValue <span class="operator">=</span> <span class="type">Array</span>(stack.wrappedValue.prefix(index <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line">                        &#125;),</span><br><span class="line">                    label: &#123; <span class="type">EmptyView</span>() &#125;</span><br><span class="line">                )</span><br><span class="line">                view</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">EmptyView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Evaluating-the-solution"><a href="#Evaluating-the-solution" class="headerlink" title="Evaluating the solution"></a>Evaluating the solution</h3><p>We can now manage navigation with a single piece of state, rather than various pieces of state distributed among our views. Pushing new screens is as simple as <code>stack.append(.newScreen)</code>, and if the user taps or swipes back, or uses the long press gesture to go further back, the navigation state will automatically get updated to reflect the change. Programmatically popping is as simple as <code>stack = stack.dropLast()</code>, and you can easily pop back to the root or to a specific screen, because the navigation stack can be examined at runtime.</p>
<p>The screen views themselves no longer need to have any knowledge of any other screens in the navigation flow - they can simply invoke a closure after any event (e.g. a button tap, API response, timer etc.) and leave the coordinator to decide what view, if any, should be pushed or presented.</p>
<p>Not only does this make the coordinator pattern more at home in SwiftUI, it even has some advantages over the coordinator pattern in UIKit. With this approach, coordinators are just views, which means they can be composed and configured in all the normal ways views can. You can present a coordinator, add it to a <code>TabView</code>, or even push a child coordinator onto the navigation stack of a parent coordinator. In UIKit, child coordinators are a useful pattern, but some extra work is often required: e.g. to keep a strong reference to the child coordinator, pass it a <code>UINavigationController</code> and tell it to <code>start()</code>. None of that extra work is necessary in the SwiftUI version. The one caveat is that the child coordinator should only ever be the top view in its parent’s stack - as the parent passes navigation responsibilities to the child when it is pushed.</p>
<!-- <div class="alert info"><p>This is why <code>NStack</code> does not wrap its content in a <code>NavigationView</code> - so that multiple coordinators can be nested within a single <code>NavigationView</code>. </p>
</div> -->

<p>In the example above the state was held by the coordinator itself, but the approach works equally well if you prefer to use view models. Here’s an idea of how the example above might be re-written with view models:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppCoordinatorViewModel</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Screen</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        stack.push(.home(.<span class="keyword">init</span>(onGoTapped: showNumberList)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showNumberList</span>()</span> &#123;</span><br><span class="line">        stack.push(.numberList(.<span class="keyword">init</span>(onNumberSelected: showNumber, cancel: pop)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showNumber</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        stack.push(.number(.<span class="keyword">init</span>(number: number, cancel: popToRoot)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span>()</span> &#123;</span><br><span class="line">        stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">popToRoot</span>()</span> &#123;</span><br><span class="line">        stack.popToRoot()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppCoordinator</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">AppCoordinatorViewModel</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">NStack</span>(stack: <span class="variable">$viewModel</span>.stack) &#123; screen <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> screen &#123;</span><br><span class="line">                <span class="keyword">case</span> .home(<span class="keyword">let</span> viewModel):</span><br><span class="line">                    <span class="type">HomeView</span>(viewModel: viewModel)</span><br><span class="line">                <span class="keyword">case</span> .numberList(<span class="keyword">let</span> viewModel):</span><br><span class="line">                    <span class="type">NumberListView</span>(viewModel: viewModel)</span><br><span class="line">                <span class="keyword">case</span> .number(<span class="keyword">let</span> viewModel):</span><br><span class="line">                    <span class="type">NumberView</span>(viewModel: viewModel)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NStack</code> is available on <a target="_blank" rel="noopener" href="https://github.com/johnpatrickmorgan/NStack">GitHub</a>. The library also includes a <code>Stack</code> object that acts as a thin wrapper around an array, adding some convenience methods for pushing and popping to a particular screen. You can see it in action in the view model example above. </p>
<p>I’d love to hear your thoughts on whether this approach is useful and if it has any downsides I haven’t considered.</p>
<div class="alert warning"><p>One word of warning: at the moment, SwiftUI does not support increasing the navigation stack by more than one in a single update. I’ve opened <code>FB9200490</code> in the hope that this will be resolved.</p>
</div>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Coordinator/" rel="tag">Coordinator</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Navigation/" rel="tag">Navigation</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Swift/" rel="tag">Swift</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/SwiftUI/" rel="tag">SwiftUI</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2016/05/11/URLPatternMatching/"
                    data-tooltip="URL Pattern Matching"
                    aria-label="NEXT: URL Pattern Matching"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyright &copy; 2021 John Patrick Morgan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2016/05/11/URLPatternMatching/"
                    data-tooltip="URL Pattern Matching"
                    aria-label="NEXT: URL Pattern Matching"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="3">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://johnpatrickmorgan.github.io/2021/07/03/NStack/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/MajorMorgan.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">John Patrick Morgan</h4>
        
            <div id="about-card-bio"><p>Recovering Objective-C developer, one-time <a target="_blank" rel="noopener" href="http://www.johnpatrickmorgan.co.uk/">music composer</a>, now evolving with Swift.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>iOS Developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                London
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-rnzr29pvueupnjebld222kvwn694gzofotbmohuek4jzonvotfxtrwo9iwgl.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'c86c0ea73885f7f5bf5b',
              clientSecret: 'f62a7e7c400e1dd6253c922492b76f9a4505dc27',
              repo: 'johnpatrickmorgan.github.io',
              owner: 'johnpatrickmorgan',
              admin: ['johnpatrickmorgan'],
              id: '2021/07/03/NStack/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
